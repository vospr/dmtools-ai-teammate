name: Learning AI Teammate

on:
  workflow_dispatch:
    inputs:
      ticket_key:
        description: 'Jira ticket key to process (e.g., ATL-2)'
        required: true
        type: string
      config_file:
        description: 'Path to agent config (relative to repo root)'
        required: false
        type: string
        default: 'agents/learning_questions.json'

permissions:
  contents: read
  actions: read

jobs:
  process-ticket:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
      
      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '23'
      
      - name: Install dmtools CLI
        env:
          DMTOOLS_LOCAL_SOURCE: ${{ github.workspace }}/releases
        run: |
          echo "üì¶ Installing dmtools CLI..."
          
          # Set and verify DMTOOLS_LOCAL_SOURCE environment variable
          export DMTOOLS_LOCAL_SOURCE="${{ github.workspace }}/releases"
          echo "DMTOOLS_LOCAL_SOURCE=$DMTOOLS_LOCAL_SOURCE"
          
          # Verify local files exist
          if [ -f "$DMTOOLS_LOCAL_SOURCE/build/libs/dmtools-latest-all.jar" ]; then
            echo "‚úÖ Found dmtools.jar: $DMTOOLS_LOCAL_SOURCE/build/libs/dmtools-latest-all.jar"
            ls -lh "$DMTOOLS_LOCAL_SOURCE/build/libs/dmtools-latest-all.jar"
          else
            echo "‚ö†Ô∏è Local JAR not found at: $DMTOOLS_LOCAL_SOURCE/build/libs/dmtools-latest-all.jar"
          fi
          
          if [ -f "$DMTOOLS_LOCAL_SOURCE/dmtools.sh" ]; then
            echo "‚úÖ Found dmtools.sh: $DMTOOLS_LOCAL_SOURCE/dmtools.sh"
            ls -lh "$DMTOOLS_LOCAL_SOURCE/dmtools.sh"
          else
            echo "‚ö†Ô∏è Local dmtools.sh not found at: $DMTOOLS_LOCAL_SOURCE/dmtools.sh"
          fi
          
          # Verify directory structure
          echo "Directory structure:"
          ls -la "$DMTOOLS_LOCAL_SOURCE" || echo "Cannot list releases directory"
          ls -la "$DMTOOLS_LOCAL_SOURCE/build/libs" 2>/dev/null || echo "Cannot list build/libs directory"
          
          # Use local install.sh from repository checkout (preferred - has access to local files)
          # Or download from vospr/dmtools main branch (raw content)
          if [ -f "${{ github.workspace }}/install.sh" ]; then
            echo "Using local install.sh from repository..."
            # Ensure environment variable is set before running
            export DMTOOLS_LOCAL_SOURCE="$DMTOOLS_LOCAL_SOURCE"
            bash "${{ github.workspace }}/install.sh"
          else
            echo "Downloading install.sh from vospr/dmtools main branch..."
            # Pass environment variable to the downloaded script via env
            env DMTOOLS_LOCAL_SOURCE="$DMTOOLS_LOCAL_SOURCE" bash <(curl -fsSL https://raw.githubusercontent.com/vospr/dmtools/main/install.sh)
          fi
          
          # Add dmtools bin directory to PATH for all subsequent steps
          echo "$HOME/.dmtools/bin" >> $GITHUB_PATH
          
          # Verify installation location
          echo "üîç Verifying installation location..."
          echo "Install directory: $HOME/.dmtools"
          ls -la "$HOME/.dmtools/bin" || echo "‚ö†Ô∏è bin directory not found"
          ls -la "$HOME/.dmtools/bin/dmtools" || echo "‚ö†Ô∏è dmtools script not found"
          
          # Verify installation in current step
          export PATH="$HOME/.dmtools/bin:$PATH"
          if command -v dmtools >/dev/null 2>&1; then
            echo "‚úÖ dmtools found in PATH"
            dmtools --version || echo "‚ö†Ô∏è dmtools version check failed"
          else
            echo "‚ùå dmtools not found in PATH after installation"
            echo "Current PATH: $PATH"
            exit 1
          fi
      
      - name: Verify dmtools CLI
        run: |
          echo "üîç Verifying dmtools installation..."
          echo "PATH: $PATH"
          echo "Checking for dmtools..."
          
          # Ensure PATH includes dmtools location
          export PATH="$HOME/.dmtools/bin:$PATH"
          
          if command -v dmtools >/dev/null 2>&1; then
            echo "‚úÖ dmtools found at: $(which dmtools)"
            dmtools --version
            echo "‚úÖ dmtools is working"
            dmtools list | head -20 || echo "‚ö†Ô∏è Cannot list tools (non-critical)"
          else
            echo "‚ùå dmtools not found in PATH"
            echo "Searching for dmtools..."
            find "$HOME" -maxdepth 4 -type f -name "dmtools" 2>/dev/null | head -5 || echo "No dmtools found"
            exit 1
          fi
      
      - name: Test Jira Connection
        env:
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_BASE_PATH: ${{ vars.JIRA_BASE_PATH }}
          JIRA_AUTH_TYPE: ${{ vars.JIRA_AUTH_TYPE }}
        run: |
          echo "üîó Testing Jira connection..."
          # Ensure PATH includes dmtools
          export PATH="$HOME/.dmtools/bin:$PATH"
          # Trim whitespace/newlines from JIRA_BASE_PATH (fix Windows line endings)
          export JIRA_BASE_PATH=$(echo "$JIRA_BASE_PATH" | tr -d '\r\n' | xargs)
          export JIRA_AUTH_TYPE=$(echo "$JIRA_AUTH_TYPE" | tr -d '\r\n' | xargs)
          echo "JIRA_BASE_PATH='$JIRA_BASE_PATH'"
          echo "JIRA_AUTH_TYPE='$JIRA_AUTH_TYPE'"
          # Test Jira connection using get_my_profile (correct tool name)
          dmtools jira_get_my_profile > /dev/null 2>&1 && echo "‚úÖ Jira connection successful" || echo "‚ö†Ô∏è Jira connection test failed (check credentials)"
      
      - name: Get Ticket Information
        id: get_ticket
        env:
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_BASE_PATH: ${{ vars.JIRA_BASE_PATH }}
          JIRA_AUTH_TYPE: ${{ vars.JIRA_AUTH_TYPE }}
        run: |
          echo "üìã Fetching ticket ${{ inputs.ticket_key }}..."
          # Ensure PATH includes dmtools
          export PATH="$HOME/.dmtools/bin:$PATH"
          
          # Trim whitespace/newlines from environment variables (fix Windows line endings)
          export JIRA_BASE_PATH=$(echo "$JIRA_BASE_PATH" | tr -d '\r\n' | xargs)
          export JIRA_AUTH_TYPE=$(echo "$JIRA_AUTH_TYPE" | tr -d '\r\n' | xargs)
          
          # Verify dmtools is available
          if ! command -v dmtools >/dev/null 2>&1; then
            echo "‚ùå ERROR: dmtools not found in PATH"
            echo "PATH: $PATH"
            echo "Checking installation..."
            ls -la "$HOME/.dmtools/bin" || echo "Install directory not found"
            exit 1
          fi
          
          # Fetch ticket - capture all output first, then extract JSON
          # Based on test results: dmtools may output debug messages before JSON
          dmtools jira_get_ticket ${{ inputs.ticket_key }} > ticket_raw.txt 2>ticket_error.log
          
          # Check for errors in stderr
          if [ -s ticket_error.log ]; then
            echo "‚ö†Ô∏è WARNING: Errors/warnings from dmtools:"
            cat ticket_error.log
          fi
          
          # Extract JSON from output (handle debug messages before JSON)
          # Pattern from test results: find first { and extract to end
          if grep -q '{' ticket_raw.txt; then
            # Find first { and extract everything from there
            sed -n '/^{/,$p' ticket_raw.txt > ticket.json
            echo "‚úÖ Extracted JSON from dmtools output"
          else
            # No JSON found, use raw output
            cp ticket_raw.txt ticket.json
            echo "‚ö†Ô∏è No JSON marker found, using raw output"
          fi
          
          # Check if file is empty
          if [ ! -s ticket.json ]; then
            echo "‚ùå ERROR: ticket.json is empty"
            echo "Raw output:"
            cat ticket_raw.txt
            echo "Stderr output:"
            cat ticket_error.log
            exit 1
          fi
          
          # Check file size
          FILE_SIZE=$(wc -c < ticket.json)
          echo "Ticket JSON file size: $FILE_SIZE bytes"
          
          # Validate JSON syntax (non-blocking)
          if jq empty ticket.json 2>jq_error.log; then
            echo "‚úÖ JSON is valid"
          else
            echo "‚ö†Ô∏è WARNING: JSON validation failed, but continuing with fallback extraction"
            if [ -s jq_error.log ]; then
              echo "jq error:"
              head -20 jq_error.log
            fi
          fi
          
          # Extract summary using multiple fallback methods (pattern from test results)
          SUMMARY=""
          
          # Method 1: Try jq (most reliable)
          if command -v jq >/dev/null 2>&1; then
            SUMMARY=$(jq -r '.fields.summary // empty' ticket.json 2>/dev/null | grep -v '^null$' | head -1)
          fi
          
          # Method 2: Try grep/sed (fallback from test results)
          if [ -z "$SUMMARY" ] || [ "$SUMMARY" = "null" ] || [ "$SUMMARY" = "empty" ]; then
            echo "‚ö†Ô∏è jq extraction failed, trying grep fallback"
            SUMMARY=$(grep -oP '"summary"\s*:\s*"\K[^"]*' ticket.json 2>/dev/null | head -1)
          fi
          
          # Method 3: Try Python if available (most robust)
          if [ -z "$SUMMARY" ] || [ "$SUMMARY" = "null" ]; then
            if command -v python3 >/dev/null 2>&1; then
              echo "‚ö†Ô∏è grep extraction failed, trying Python fallback"
              SUMMARY=$(python3 -c "import json, sys; data=json.load(sys.stdin); print(data.get('fields', {}).get('summary', 'Unknown'))" < ticket.json 2>/dev/null || echo "")
            fi
          fi
          
          # Final fallback
          if [ -z "$SUMMARY" ] || [ "$SUMMARY" = "null" ]; then
            SUMMARY="Unknown"
            echo "‚ö†Ô∏è All extraction methods failed, using default 'Unknown'"
          fi
          
          echo "Ticket summary: $SUMMARY"
          echo "TICKET_SUMMARY=$SUMMARY" >> $GITHUB_OUTPUT
          
          # Display ticket info (first part only to avoid log spam)
          echo "Ticket JSON preview (first 500 chars):"
          head -c 500 ticket.json
          echo "..."
      
      - name: Build AI Prompt
        id: build_prompt
        env:
          TICKET_KEY: ${{ inputs.ticket_key }}
        run: |
          echo "ü§ñ Building AI prompt..."
          
          # Read ticket data with fallback methods (same pattern as Get Ticket Information step)
          TICKET_JSON=$(cat ticket.json)
          
          # Extract SUMMARY with fallback methods
          SUMMARY=""
          if command -v jq >/dev/null 2>&1; then
            SUMMARY=$(echo "$TICKET_JSON" | jq -r '.fields.summary // empty' 2>/dev/null | grep -v '^null$' | head -1)
          fi
          if [ -z "$SUMMARY" ] || [ "$SUMMARY" = "null" ] || [ "$SUMMARY" = "empty" ]; then
            SUMMARY=$(grep -oP '"summary"\s*:\s*"\K[^"]*' ticket.json 2>/dev/null | head -1 || echo "Unknown")
          fi
          if [ -z "$SUMMARY" ] || [ "$SUMMARY" = "null" ]; then
            SUMMARY="Unknown"
          fi
          
          # Extract DESCRIPTION with fallback methods
          DESCRIPTION=""
          if command -v jq >/dev/null 2>&1; then
            # Try to get description, handle ADF format
            DESCRIPTION=$(echo "$TICKET_JSON" | jq -r '.fields.description // empty' 2>/dev/null)
            # If description is an object (ADF format), try to extract text
            if echo "$DESCRIPTION" | jq -e 'type == "object"' >/dev/null 2>&1; then
              # Try to extract text from ADF content
              DESCRIPTION=$(echo "$DESCRIPTION" | jq -r '.content[]? | select(.type == "paragraph") | .content[]? | select(.type == "text") | .text' 2>/dev/null | tr '\n' ' ' | head -c 500 || echo "No description")
            fi
            if [ -z "$DESCRIPTION" ] || [ "$DESCRIPTION" = "null" ] || [ "$DESCRIPTION" = "empty" ]; then
              DESCRIPTION="No description"
            fi
          else
            DESCRIPTION="No description"
          fi
          
          # Clean up description (remove newlines, limit length)
          DESCRIPTION=$(echo "$DESCRIPTION" | tr '\n' ' ' | sed 's/  */ /g' | head -c 1000)
          
          # Create prompt file using printf to avoid YAML heredoc parsing issues
          # This approach is YAML-safe and doesn't require heredoc syntax
          printf 'You are an Experienced Business Analyst analyzing Jira tickets.\n\nTICKET TO ANALYZE:\nKey: ${TICKET_KEY}\nSummary: ${SUMMARY}\nDescription:\n${DESCRIPTION}\n\nYOUR TASK:\nGenerate 2-5 clarifying questions for any unclear requirements.\n\nOUTPUT FORMAT (must be valid JSON array):\n[\n  {\n    "summary": "Question summary (max 120 chars)",\n    "priority": "High|Medium|Low",\n    "description": "Detailed question in markdown"\n  }\n]\n\nIf everything is crystal clear, output: []\n\nIMPORTANT: Output ONLY the JSON array, no other text.\n\nJSON array:' > prompt_template.txt
          
          # Use envsubst for variable substitution if available
          if command -v envsubst >/dev/null 2>&1; then
            export TICKET_KEY SUMMARY DESCRIPTION
            envsubst < prompt_template.txt > prompt.txt
            rm -f prompt_template.txt
          else
            # Fallback: use sed for substitution (envsubst not available)
            export TICKET_KEY SUMMARY DESCRIPTION
            sed "s|\${TICKET_KEY}|$TICKET_KEY|g; s|\${SUMMARY}|$SUMMARY|g; s|\${DESCRIPTION}|$DESCRIPTION|g" prompt_template.txt > prompt.txt
            rm -f prompt_template.txt
          fi
          
          echo "Prompt created:"
          head -30 prompt.txt
          echo "..."
      
      - name: Call Gemini AI
        id: ai_response
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          echo "üß† Calling Gemini AI..."
          # Ensure PATH includes dmtools
          export PATH="$HOME/.dmtools/bin:$PATH"
          
          PROMPT=$(cat prompt.txt)
          dmtools gemini_ai_chat "$PROMPT" > response.md
          
          echo "AI Response:"
          cat response.md
          
          # Validate JSON
          if grep -q '\[' response.md; then
            echo "‚úÖ JSON array found in response"
          else
            echo "‚ö†Ô∏è No JSON array found in response"
          fi
      
      - name: Parse Questions
        id: parse_questions
        run: |
          echo "üìù Parsing questions from AI response..."
          
          # Read response file
          RESPONSE=$(cat response.md)
          echo "Response length: ${#RESPONSE} characters"
          echo "First 500 chars of response:"
          echo "$RESPONSE" | head -c 500
          echo ""
          echo "..."
          
          # Method 1: Try to extract JSON using Python (most robust)
          JSON=""
          if command -v python3 >/dev/null 2>&1; then
            echo "Using Python to extract JSON..."
            JSON=$(echo "$RESPONSE" | python3 -c "
import json
import re
import sys

response = sys.stdin.read()

# Try multiple extraction methods
# Method 1: Look for JSON array in code blocks
code_block_match = re.search(r'\`\`\`(?:json)?\s*(\[[\s\S]*?\])\s*\`\`\`', response, re.MULTILINE)
if code_block_match:
    json_str = code_block_match.group(1)
    try:
        json.loads(json_str)
        print(json_str)
        sys.exit(0)
    except:
        pass

# Method 2: Look for JSON array between brackets (balanced)
bracket_start = response.find('[')
if bracket_start != -1:
    bracket_count = 0
    bracket_end = -1
    for i in range(bracket_start, len(response)):
        if response[i] == '[':
            bracket_count += 1
        elif response[i] == ']':
            bracket_count -= 1
            if bracket_count == 0:
                bracket_end = i
                break
    if bracket_end != -1:
        json_str = response[bracket_start:bracket_end+1]
        try:
            json.loads(json_str)
            print(json_str)
            sys.exit(0)
        except:
            pass

# Method 3: Try to find any valid JSON array
json_match = re.search(r'\[[\s\S]*?\]', response)
if json_match:
    json_str = json_match.group(0)
    try:
        parsed = json.loads(json_str)
        if isinstance(parsed, list):
            print(json_str)
            sys.exit(0)
    except:
        pass

sys.exit(1)
" 2>/dev/null || echo "")
          fi
          
          # Method 2: Fallback to grep if Python failed
          if [ -z "$JSON" ]; then
            echo "Python extraction failed, trying grep fallback..."
            # Try to find JSON array, handling multiline
            JSON=$(echo "$RESPONSE" | grep -oPz '(?s)\[[\s\S]*?\]' | tr -d '\0' | head -1)
          fi
          
          # Method 3: Try sed to extract between first [ and last ]
          if [ -z "$JSON" ]; then
            echo "Grep extraction failed, trying sed fallback..."
            FIRST_BRACKET=$(echo "$RESPONSE" | grep -n '\[' | head -1 | cut -d: -f1)
            if [ -n "$FIRST_BRACKET" ]; then
              JSON=$(echo "$RESPONSE" | sed -n "${FIRST_BRACKET},\$p" | sed -n '1,/\]/p' | tr -d '\n' | sed 's/.*\(\[.*\]\).*/\1/')
            fi
          fi
          
          # Check if we found JSON
          if [ -z "$JSON" ]; then
            echo "No JSON array found in response - requirements are clear!"
            echo "Full response for debugging:"
            cat response.md
            echo "QUESTION_COUNT=0" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Extracted JSON (first 200 chars):"
          echo "$JSON" | head -c 200
          echo "..."
          
          # Clean and validate JSON using Python (more forgiving)
          if command -v python3 >/dev/null 2>&1; then
            echo "Validating and cleaning JSON with Python..."
            CLEAN_JSON=$(echo "$JSON" | python3 -c "
import json
import sys

try:
    data = json.load(sys.stdin)
    if isinstance(data, list):
        print(json.dumps(data, indent=2))
        sys.exit(0)
    else:
        print('Not a list', file=sys.stderr)
        sys.exit(1)
except json.JSONDecodeError as e:
    print(f'JSON decode error: {e}', file=sys.stderr)
    sys.exit(1)
" 2>json_error.log || echo "")
            
            if [ -n "$CLEAN_JSON" ]; then
              echo "$CLEAN_JSON" > questions.json
              JSON="$CLEAN_JSON"
            else
              echo "‚ö†Ô∏è Python validation failed, error:"
              cat json_error.log || echo "No error log"
              echo "Trying jq validation..."
            fi
          fi
          
          # Fallback: Validate with jq
          if [ ! -f questions.json ] || [ ! -s questions.json ]; then
            echo "$JSON" | jq . > questions.json 2>jq_error.log || {
              echo "‚ùå Invalid JSON extracted!"
              echo "Extracted JSON:"
              echo "$JSON"
              echo "jq error:"
              cat jq_error.log
              echo "Full response:"
              cat response.md
              exit 1
            }
          fi
          
          # Get question count
          QUESTION_COUNT=$(cat questions.json | jq 'length' 2>/dev/null || echo "0")
          echo "Found $QUESTION_COUNT question(s)"
          echo "QUESTION_COUNT=$QUESTION_COUNT" >> $GITHUB_OUTPUT
          
          # Display questions
          if [ "$QUESTION_COUNT" -gt 0 ]; then
            echo "Questions:"
            cat questions.json | jq -r '.[] | "- \(.summary) [\(.priority)]"'
          else
            echo "No questions found in JSON array"
          fi
      
      - name: Create Sub-tickets
        if: steps.parse_questions.outputs.QUESTION_COUNT > 0
        env:
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_BASE_PATH: ${{ vars.JIRA_BASE_PATH }}
          JIRA_AUTH_TYPE: ${{ vars.JIRA_AUTH_TYPE }}
          TICKET_KEY: ${{ inputs.ticket_key }}
        run: |
          echo "üé´ Creating sub-tickets..."
          
          PROJECT_KEY=$(echo "$TICKET_KEY" | cut -d'-' -f1)
          QUESTIONS=$(cat questions.json)
          
          i=1
          echo "$QUESTIONS" | jq -c '.[]' | while read question; do
            SUMMARY=$(echo "$question" | jq -r '.summary')
            PRIORITY=$(echo "$question" | jq -r '.priority')
            DESC=$(echo "$question" | jq -r '.description')
            
            # Build summary with prefix
            FULL_SUMMARY="[Q$i] $SUMMARY"
            if [ ${#FULL_SUMMARY} -gt 120 ]; then
              FULL_SUMMARY="${FULL_SUMMARY:0:117}..."
            fi
            
            # Build description
            FULL_DESC="$DESC

---
*Generated by AI Teammate*
*Priority: $PRIORITY*"
            
            echo "Creating question $i: $FULL_SUMMARY"
            
            # Ensure PATH includes dmtools
            export PATH="$HOME/.dmtools/bin:$PATH"
            
            # Create ticket via dmtools
            # Note: This is a simplified version. The actual JavaScript action would be more robust.
            dmtools jira_create_ticket_with_json "{
              \"project\": \"$PROJECT_KEY\",
              \"fieldsJson\": {
                \"summary\": \"$FULL_SUMMARY\",
                \"description\": \"$FULL_DESC\",
                \"issuetype\": {\"name\": \"Sub-task\"},
                \"parent\": {\"key\": \"$TICKET_KEY\"},
                \"priority\": {\"name\": \"$PRIORITY\"}
              }
            }" || echo "Failed to create sub-ticket $i"
            
            i=$((i+1))
          done
      
      - name: Add Label
        if: steps.parse_questions.outputs.QUESTION_COUNT >= 0
        env:
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_BASE_PATH: ${{ vars.JIRA_BASE_PATH }}
          JIRA_AUTH_TYPE: ${{ vars.JIRA_AUTH_TYPE }}
          TICKET_KEY: ${{ inputs.ticket_key }}
        run: |
          echo "üè∑Ô∏è Adding label..."
          # Trim whitespace/newlines from environment variables (fix Windows line endings)
          export JIRA_BASE_PATH=$(echo "$JIRA_BASE_PATH" | tr -d '\r\n' | xargs)
          export JIRA_AUTH_TYPE=$(echo "$JIRA_AUTH_TYPE" | tr -d '\r\n' | xargs)
          # Ensure PATH includes dmtools
          export PATH="$HOME/.dmtools/bin:$PATH"
          
          if [ "${{ steps.parse_questions.outputs.QUESTION_COUNT }}" -eq "0" ]; then
            dmtools jira_add_label $TICKET_KEY "ai_no_questions_needed"
          else
            dmtools jira_add_label $TICKET_KEY "ai_questions_asked"
          fi
      
      - name: Summary
        run: |
          echo "========================================" 
          echo "AI TEAMMATE PROCESSING COMPLETE"
          echo "========================================"
          echo "Ticket: ${{ inputs.ticket_key }}"
          echo "Summary: ${{ steps.get_ticket.outputs.TICKET_SUMMARY }}"
          echo "Questions Created: ${{ steps.parse_questions.outputs.QUESTION_COUNT }}"
          echo "========================================"
          
          echo "‚úÖ Check Jira: ${{ vars.JIRA_BASE_PATH }}/browse/${{ inputs.ticket_key }}"
      
      - name: Upload Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ai-teammate-results-${{ github.run_number }}
          path: |
            ticket.json
            prompt.txt
            response.md
            questions.json
          retention-days: 7
